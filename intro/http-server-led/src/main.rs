use anyhow::Result;
use core::str;
use embedded_svc::{
    http::{Headers, Method}, 
    io::{Read, Write},
};
use esp_idf_hal::delay::FreeRtos;
use esp_idf_hal::prelude::Peripherals;
use esp_idf_svc::{
    eventloop::EspSystemEventLoop,
    http::server::{Configuration, EspHttpServer},
};
use std::{
    sync::{Arc, Mutex},
    thread::sleep,
    time::Duration,
    sync::atomic::{AtomicBool, Ordering},
//    ffi::c_void,
};
use std::sync::mpsc;
use std::thread;
use rgb_led::{RGB8, WS2812RMT};
use wifi::wifi;
// If using the `binstart` feature of `esp-idf-sys`, always keep this module imported
use esp_idf_sys as _;
use serde::{Deserialize, Serialize};
//use serde_json_core::*;

// Max payload length
const MAX_LEN: usize = 128;

#[toml_cfg::toml_config]
pub struct Config {
    #[default("")]
    wifi_ssid: &'static str,
    #[default("")]
    wifi_psk: &'static str,
}

#[derive(Serialize, Deserialize, Debug, Copy, Clone)]
struct UserSettings {
    red: u8,
    blue: u8,
    green: u8,
    mode: bool,
    delay :u32,
}

fn main() -> Result<()> {
    esp_idf_sys::link_patches();
    esp_idf_svc::log::EspLogger::initialize_default();

    let peripherals = Peripherals::take().unwrap();
    let sysloop = EspSystemEventLoop::take()?;

    // The constant `CONFIG` is auto-generated by `toml_config`.
    let app_config = CONFIG;

    // Connect to the Wi-Fi network
    let _wifi = wifi(
        app_config.wifi_ssid,
        app_config.wifi_psk,
        peripherals.modem,
        sysloop,
    )?;

    /*
    let user_settings = UserSettings {
       red: 50,
       blue: 50,
       green: 0,
       mode: false,
       delay: 0,
   };

    // Serialize the UserRequest instance to a JSON string
    let json_string =  serde_json::to_string(&user_settings).unwrap();
    println!("Serialized JSON string: {}", json_string);

    // Deserialize the JSON string back into a Person instance
    let _settings: UserSettings = serde_json::from_str(&json_string).unwrap();
    println!("Deserialized Person instance: {:?}", _settings);
    */

    // Start the LED off yellow
    let led = WS2812RMT::new(peripherals.pins.gpio2, peripherals.rmt.channel0)?;
    let led_main = Arc::new(Mutex::new(led));
    let temp_led = led_main.clone();    
    temp_led.lock().unwrap().set_pixel(RGB8::new(50, 50, 0)).unwrap();

    // Set the HTTP server
    let mut server = EspHttpServer::new(&Configuration::default())?;

    let should_stop = Arc::new(AtomicBool::new(false));

    // http://<sta ip>/ handler
    server.fn_handler("/", Method::Get, |request| {
        let html = index_html();
        let mut response = request.into_ok_response()?;
        response.write_all(html.as_bytes())?;
        Ok(())
    })?;

    server.fn_handler("/settings", Method::Post, move |mut request| {
        let len = request.content_len().unwrap_or(0) as usize;

        if len > MAX_LEN {
            request.into_status_response(413)?
                .write_all("Request too big".as_bytes())?;
            return Ok(());
        }

        let mut buf = vec![0; len];
        request.read_exact(&mut buf)?;

        let mut resp = request.into_ok_response()?;
        if let Ok(form) = serde_json::from_slice::<UserSettings>(&buf) {

            should_stop.store(false, Ordering::Relaxed);
            //let running = Arc::new(Mutex::new(form.mode));

            let (tx, rx) = mpsc::channel();
            
            let handle = thread::spawn({
                let _running = should_stop.clone();
                let _my_led = temp_led.clone();
                let _my_struct = form.clone();
                move || {
                    tx.send("Done").unwrap();
                    //while !thread_should_stop.load(Ordering::Relaxed) {
                    //    led_task(_my_led, _my_struct/*, _running*/);                                                
                    //}
                }
            });
            handle.join().unwrap();
            let _result = rx.recv().unwrap();
            //*running.lock().unwrap() = false;
            write!(
                resp,
                "{}, red {}-blue {}-green {}!",
                _result, form.red, form.blue, form.green
            )?;
        } else {
            resp.write_all("JSON error".as_bytes())?;
        }
        
        Ok(())
    })?;

    /*
    server.fn_handler("/color", Method::Post, move |mut request| {
        let mut buffer = [0_u8; 11]; // ex: 245,16,32
        let bytes_read = request.read(&mut buffer).unwrap();
        let input = str::from_utf8(&buffer[0..bytes_read]).unwrap();
        println!("Color {}",input);

        let values: Vec<&str> =input.split(",").collect();
        println!("red {}",values[0]);
        println!("green {}",values[1]);
        println!("blue {}",values[2]);
        let red: u8 = values[0].parse().unwrap();
        let green: u8 = values[1].parse().unwrap();
        let blue: u8 = values[2].parse().unwrap();
        let _temp_val = temp_led
            .lock()
            .unwrap()
            .set_pixel(RGB8::new(red, green, blue))
            .unwrap();
        Ok(())
    })?;
    */

    println!("Server awaiting connection");

    // Prevent program from exiting
    loop {
        sleep(Duration::from_millis(1000));
    }
}


/*
fn led_task(led: *mut c_void, data: *mut c_void) {
    let my_struct = unsafe { &mut *(data as *mut UserSettings) };
    let my_led = unsafe { &mut *(led as *mut Arc<Mutex<WS2812RMT<'_>>>) };
    loop {
        FreeRtos::delay_ms(my_struct.delay);
        println!("led task loop ...");
        let _led = my_led
        .lock()
        .unwrap()
        .set_pixel(RGB8::new(
            my_struct.red
            , my_struct.green
            , my_struct.blue))
        .unwrap();
    }
}
 */
//fn led_task(led: Arc<Mutex<WS2812RMT<'_>>>, data: UserSettings, running: Arc<Mutex<bool>>) {
fn led_task(led: Arc<Mutex<WS2812RMT<'_>>>, data: UserSettings/*, running: Arc<std::sync::atomic::AtomicBool>*/) {
    let ws2812 = led.clone();
    if data.mode {
        loop {
            ws2812
            .lock()
            .unwrap()
            .set_pixel(RGB8::new(
                0
                , 0
                , 0))
            .unwrap();
            FreeRtos::delay_ms(data.delay);
            println!("led task loop ...");
            ws2812
            .lock()
            .unwrap()
            .set_pixel(RGB8::new(
                data.red
                , data.green
                , data.blue))
            .unwrap();
            FreeRtos::delay_ms(data.delay);
            //if !*running.lock().unwrap() {
            //    break;
            //}
        }
    } else {
        ws2812
        .lock()
        .unwrap()
        .set_pixel(RGB8::new(
            data.red
            , data.green
            , data.blue))
        .unwrap();
    }
}

fn templated(content: impl AsRef<str>) -> String {
    format!(
        r#"
<html>
    <head>
        <meta charset='utf-8'>
        <title>esp-rs web server</title>
        <script src='https://cdn.jsdelivr.net/npm/@jaames/iro@5'></script>
    </head>
    <body>
        {}
        <div id='picker'></div>
        <script>
	        var colorPicker = new iro.ColorPicker('#picker', {{width:320,color: '#f00'}});
	        colorPicker.on('color:change', function(color) {{
                // log the current color as a HEX string
                console.log(color.red);
                console.log(color.green);
                console.log(color.blue);
                const xhr = new XMLHttpRequest();
                xhr.open("POST", 'http://espressif/color');
                xhr.setRequestHeader('Content-Type', 'text/plain; charset=UTF-8');
                const body = color.red+','+color.green+','+color.blue;
                console.log(body);
    	        xhr.onload = () => {{
	    	        if (xhr.readyState == 4 && xhr.status == 200) {{
		                console.log('Ok');
		            }} else {{
		                console.log('Error!');
                    }}
	            }};
	            xhr.send(body);	
            }});
        </script>
    </body>
</html>
"#,
        content.as_ref()
    )
}

fn index_html() -> String {
    templated("Hello from mcu!")
}
